\chapter{Einleitung}
Seit einiger Zeit wird an der Hochschule Karlsruhe die Projektidee eines künstlichen Chors verfolgt, dessen Ziel darin besteht, eine Audiospur simultan in mehreren Tonhöhen wiederzugeben, um einen mehrstimmigen Chor zu erzeugen. Das zugrundeliegende technische Prinzip lässt sich recht leicht erläutern: die originale Tonspur wird mittels FFT in den Frequenzbereich transformiert, wo das Signal in die gewünschte Tonhöhe bzw. Frequenzbereich verschoben wird. Anschließend werden die Signale zurück in den Zeitbereich transformiert und abgespielt. Allerdings gestaltet sich die Umsetzung weitaus anspruchsvoller als das theoretische Konzept. Beispielsweise führen Aussetzer im WLA-Netzwerk, Puffergrößen der Audiotreiber und diskrete Stützstellen des Frequenzspektrums zu unerwarteten Problemen, die sich in Form von knackenden Lautsprechern Gehör verschaffen. Nichtsdestotrotz hat der Entwicklungsprozess den Punkt erreicht, an dem der Chor noch kaum unerwünschte Töne von sich gibt, weshalb nun die erste große Erweiterung angestrebt wird. Aktuell setzt sich das System aus einem Master-PC und vier BeagleBones zusammen, die jeweils mit einem Lautsprecher ausgestattet in einem Raum verteilt werden. Auf dem Master wird eine Tonspur eingespielt, die er in die gewünschten Tonhöhen pitcht und per WLAN an die BeagleBones sendet, welche jeweils eine der Stimmen über den Lautsprecher wiedergeben.
\par
Im nächsten Schritt soll der Chor mobilisiert werden. Das heißt jedes BeagleBone plus Lautsprecher wird auf einem Roboter montiert, die bei einer Vorführung einen beliebigen Raum betreten können und diesen auf der Suche nach einem passenden Podium erkunden. Wurde Letzteres gefunden, so sollen sich die Roboter dort im Halbkreis formieren und anschließend vorsingen.

Die neue Aufgabe, die sich mit der autonomen Navigation der Roboter beschäftigt, kann vollkommen entkoppelt von dem Chor betrachtet und bearbeitet werden. Dieser zweite Entwicklungsstrang befindet sich allerdings noch im Anfangsstadium, da sich bisher nur ein einzelnes Entwicklungsprojekt \cite{Turtleboys} dem Thema gewidmet hat. In dieser Arbeit wurde ein erster Grundstein gelegt, der sich einerseits aus der Auswahl und Inbetriebnahme der Roboter, andererseits aus einem ersten Proof-of-Concept in Sachen Navigation zusammensetzt.

Als mobile Plattform für die Lautsprecher fiel die Wahl auf den Turtlebot 2 \cite{Turtlebot}, der von Willow Garage entwickelt wurde. Der Roboter setzt sich aus der Kobuki-Basis, einem Rechner und einer ASUS-Xtion-Pro-Live zusammen, wobei Letztere sowohl Kamera als auch Tiefensensor zur Verfügung stellt. Der Turtlebot 2 bringt als Vorteil mit sich, dass der Roboter weite Anwendung im Bereich von Hobby- und Forschungsanwendungen findet, weshalb eine breite Community-Untersützung zur Verfügung steht. Ein in dieser Arbeit wichtiges Beispiel stellt die Simulation des Roboters mithilfe von GAZEBO \cite{gazebo} dar: Hier besteht bereits eine vollständige Integration des Turtlebot 2, die quelloffen zugänglich ist. Im Rahmen der Vorgängerarbeit wurde der Roboter zusätzlich mit dem Laserscanner Tim551 der Marke SICK ausgestattet \cite{SICK}, der als primärer Sensor für die Navigation verwendet wird.

Die Programmierung erfolgt mithilfe des sogenannten Robot-Operating-System (ROS), wobei es sich ironischerweise um kein Betriebssystem sondern eine Middleware handelt, die eine Vielzahl von Tools und Paketen für die autonome Navigation bereitstellt. Dadurch müssen die Algorithmen für die Navigation und Kartographierung nicht eigenständig implementiert werden, sondern können in Form von ROS-Paketen eingesetzt werden, sodass sich die Inbetriebnahme auf die Parametrisierung der ROS-Funktionen beschränkt. Außerdem beinhaltet ROS ein Netzwerk, über das die Roboter kommunizieren können. Mithilfe der Kommunikationskanäle können auch externe Werkzeuge auf relevanten Daten zugreifen, womit komfortable und effiziente Debugging-Wege geschaffen werden. Umgekehrt können zu Beginn die Roboter auch aus dem Netz entfernt und durch ein Simulationstool wie GAZEBO ersetzt werden. So können die Algorithmen zunächst anhand einer Simulation erprobt und konfiguriert werden und im Anschluss unverändert auf die Roboter übertragen werden.

Die im Vorgängerprojekt \cite{Turtleboys} erarbeitete Navigationslösung basiert auf dem ROS-Navigation-Stack und setzt sich aus zwei Teilen zusammen. Im ersten Schritt wird mit dem ROS-Paket \lstinline{hector_slam}{} \cite{WikiHector} eine Karte der Umgebung aufgezeichnet. Anschließend navigieren die Roboter anhand der Karte zu dem vorgegebenen Ziel, wobei das ROS-Paket \lstinline{move_base}{} \cite{WikiMoveBase} zum Einsatz kommt. Bei dessen Konfiguration wurden zwei verschiedene Ansätze verfolgt: Bei dem Ersten erfolgt die Lokalisierung des Roboters ausschließlich anhand der Odometriedaten. Der zweite Ansatz greift auf die AMC-Lokalisierung zurück. Der Vorteil der zweiten Variante liegt darin, dass die Ausgangsposition des Roboters nicht bekannt sein muss. Bei der Navigation mittels Odometrie übertragen sich sämtliche Fehler bei der Angabe der Anfangsposition unmittelbar auf die Navigation. Im Gegensatz dazu verspricht die AMCL-Variante - zumindest theoretisch - ein höheres Maß an Robustheit. Allerdings konnte diese Hoffnung in den Experimenten nicht bestätigt werden, weshalb letzten Endes die Odometrie-Navigation verwendet wurde \cite[S. 43]{Turtleboys}. Zusätzlich sei angemerkt, dass diese Lösung nicht im Stande ist, Hindernisse, die nicht auf der Karte verzeichnet sind, während der Navigation zu erkennen, geschweige denn, denen auszuweichen.

An dieser Stelle knüpft die vorliegende Arbeit an: Die Navigation soll an den Punkt gebracht werden, wo die Roboter im Stande sind, sich selbst auf der Karte zu lokalisieren, unerwartete Hindernisse zu detektieren und diesen entsprechend auszuweichen. Hierfür soll auf bestehende Möglichkeiten des ROS-Navigation-Stack zurückgegriffen werden, um die Menge von Lösungsmöglichkeiten einzuschränken. Auch die Anforderung, dass die Navigation auf eine mit \lstinline{hector_slam}{} aufgezeichnete Karte zurückgreifen kann, wird übernommen. Im ersten Schritt wird lediglich ein einzelner Roboter betrachtet. Sobald dieser die Anforderungen im Bereich der autonomen Navigation erfüllt, werden die Ergebnisse auf eine Gruppe von vier Robotern übertragen.

Die funktionalen Anforderungen dieser Arbeit bestehen darin, die autonome Navigation mehrerer Roboter zu ermöglichen. Darüber hinaus besteht der Anspruch darauf, die zugrundeliegenden Algorithmen nachzuvollziehen und zu verstehen. Die ROS-Implemententierung sollen nicht nur derartig parametrisiert werden, damit die funktionalen Anforderungen erfüllt sind. Sondern es soll der Zusammenhang zwischen den Parametern und dem Funktionsprinzip der Navigation erarbeitet werden, sodass Letzteres verstanden werden kann. Hierfür werden zu Beginn der Arbeit theoretische Grundlagen der Planung und stochastischen Modellierung diskutiert, deren elaborierte Ausführungen die Bausteine der autonomen Navigation bilden.
Ein Hauptproblem der Navigationsaufgabe besteht darin, dass die Teilprobleme nicht entkoppelt betrachtet werden können, woraus eine unerwünschte Komplexität resultiert. Um die einzelnen Komponenten isoliert betrachten zu können, wird im Rahmen dieser Arbeit auf Simulationswerkzeuge wie MATLAB und GAZEBO zurückgegriffen, in denen Daten, die unter realen Umständen mittels zusätzlicher Algorithmen geschätzt werden müssen, unmittelbar abgegriffen werden können. Anhand dieser vereinfachten Beispiele erfolgt die Diskussion der Teilprobleme wie Planung und Lokalisierung. Im Anschluss wird auf die ROS-Implementierung der Algorithmen eingegangen, die zuletzt in Betrieb genommen und in reellen Szenarien getestet wird.

Zu Beginn der Arbeit wird ROS' Navigation-Stack in seine einzelnen Komponenten unterteilt und deren Hauptfunktionen beschreiben. Im Anschluss wird das Funktionsprinzip der einzelnen Komponenten im Detail betrachtet. Diese Untersuchung beginnt bei dem globalen Planer, der als einzige Komponente mit deterministischen Modellen arbeitet und deshalb eine Sonderstellung unter den Komponenten einnimmt. Die restlichen Komponente basieren auf stochastischen Modellen, weshalb im Anschluss zuerst die Bedeutung von stochastischen Modellen in der Robotik diskutiert und am Beispiel eines Bewegungs- sowie Messmodells erläutert wird.

Der darauffolgende Abschnitt widmet sich der Kartenerstellung, wobei es sich um ein Aufgabe handelt, die nicht Teil des Navigation-Stacks ist. Allerdings bietet der hier verwendete Kartographierungsalgorithmus einen Einblick in das Funktionsprinzip stochastischer Modelle und rundet das Verständnis der Navigation insofern ab, dass nach wie vor Karten hierfür erforderlich sind. Als letzter Teil des Navigationstack wird der lokale Planer diskutiert, der auf den Dynamic Window Approach zurückgreift, um die Steuerbefehle des Roboters zu berechnen.
Ein weiterer wichtiger Aspekt für die Navigation stellt die Lokalisierung dar, weshalb im Anschluss die adaptive Monte-Carlo-Lokalisierung (AMCL) diskutiert wird, die auch unter ROS zum Einsatz kommt. 

Der Funktionsnachweis der Navigation erfolgt anhand von drei Experimenten. Zunächst wird der Fall betrachtet, dass der Roboter in dem im Vergleich zur Kartenerstellung unveränderten Raum navigieren müssen. Hierbei wird die Grundfunktion der Navigation bewiesen. Im folgenden Experiment wird der Weg des Roboters durch ein unbekanntes Hindernis versperrt, weshalb Sensordaten in die Pfadplannung integriert werden müssen, um das Objekt zu detektieren und bei der Planung zu beachten. Im letzten Versuch wird die Lokalisierung des Roboters untersucht, wofür dieser an einer unbekannten Position ausgesetzt wird, die nur durch eine ungenaue Schätzung vorgegeben wird. Hieran wird ersichtlich wie der Roboter sich orten kann, wenn er eine kurze Distanz zurücklegt, um neue Information über seine Umgebung zu sammeln.

Zuletzt wird die Implementierung der Navigationskonzepte unter ROS betrachtet. Hier werden die verschiedenen Launch-Dateien zur Fernsteuerung, Kartenaufzeichnung und Navigation vorgestellt. Außerdem wird das Zusammenspiel des Master- und der Slave-PCs beschrieben.